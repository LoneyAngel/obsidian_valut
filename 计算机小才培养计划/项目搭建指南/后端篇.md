这次的后端搭建我决定使用express，有时间的话再尝试将其转成koa的形式


## 后端
- 错误处理
	-完善的错误处理+对应的日志记录
- 404等处理
	-404等特殊情况的访问处理
- 日志轮转（日志格式）
	-实现人性化的优质日志，
		-等级分类
		-信息完整
- api文档 -> apidoc
		- 使用现代的方式实现api文档的搭建

- 数据传输类型管理 -> MIME
	-对前后端的数据传输给以标准
- 数据库⭐
	-结构
	-访问
- 代码清晰规范，项目结构清晰⭐
	-语法
		-比如：变量命名，应该避免使用和库名一致的名字
	-结构
- jwt验证令牌
	-验证
	-负载
- cookie
	-存储和管理
	-和jwt的关系
- 密码加密
	-重要信息的加密
	-加密信息的使用
- 调试信息
- 热加载

## 一.Mogodb(新技术)
### 特点及优势
- 说是对ai这种大数据使用有优势
- 采用（json）文档对象模型

### 格式
	简化写法：User.create({name})//这是当键值和变量名字一致时候的一种写法
	正常：User.create({name:name})
#### 其他
- 长度
	直接调用User.count()函数，因为是内部已经统计出来的值，性能较数组长度好
- 固定的键：id或_id（指的是objectid）
	-注意：这里的id不是string类型
//async+await使用try+catch
//不使用异步时，才使用回调的方法，即.then.....catch()的方法
##### 对文档直接操作和直接使用模型的区别
- 一般我们操作的对象分成两种，1.（单）文档
			  				2. 模型，也就是（文档集合）数据库
- 单文档类型操作后需要进行手动的save后才会生效

- 对于文档可以直接使用方法如：
				- const user = User.findone({});
				- user.update({$set :{name: "you"}})
				- 或者直接：user.name="you";

- 获取指定文档的属性值：user.get("name")
					- 或者user.name
- 设置属性值set
- 转换成object类型toObject



### 1.初始化
- 连接并创造连接池
```js
	const mongoURI = "mongodb://localhost:27017/admin";
	mongoose
	  .connect(mongoURI, {
	    maxPoolSize: 5, // 连接池大小（默认 5）
	    serverSelectionTimeoutMS: 5000, // 连接超时时间
	    socketTimeoutMS: 45000, // 操作超时时间
	  })
```

- 创造对象模型(键值，类型，主键等)
```js
const mongoose = require("mongoose");
const resourceSchema = new mongoose.Schema({
	  ulid: {
		type: String,
		required: true,
		unique: true,
		index: true,
	  },
	  name: {
		type: String,
		required: true,
	  },
});
module.exports = mongoose.model("Resource", resourceSchema);
```

### 2.普通检索
	find                 检索返回的是数组
	findOne         返回的不是数组
	findById("")  根据objectid进行检索  
```js
const User = required("../modules/user.js");
const user=User.find({});//返回全部
const userExists = await User.findOne({ account });//通过指定的信息进行检索
```

### 3.添加
```js
const User = required("../modules/user.js");
const user=User.create({
ulid:ulid,
name:name
}) 
//或者
const user = new User({
。。。
})
user.save();
```
### 4.更改
	update(选中，修改后的，可选项)
	updateone
	updatemany
```js
const User = required("../modules/user.js");
const user=User.update(({
ulid:ulid,
name:name
},{$set:{age:18}}) 
```

### 5.删除
	remove
	deleteone
	deletemany
```js
const User = required("../modules/user.js");
const user=User.remove(({
ulid:ulid,
name:name
}) ;
```

### 6.高级检索
- 函数原型
find([conditions],[projection],[options],[callback])
[conditions] : 条件 
[projection] : 键值约束
[options] : 可选项
[callback] : 回调

减号（-）+键：不需要
```js
const User = required("../modules/user.js");
const user=User.find({},“name id -_id”);//返回满足条件的特定信息
```



### 特殊的
- mongodb自带的id
提取时间戳（登陆的时间）
const timestamp = ulid.decodeTime(id);
console.log("创建时间:", new Date(timestamp).toISOString());
- 异步的使用
async+await使用try+catch
不使用异步时，才使用回调的方法，即.then.....catch()的方法
#### 为什么不能直接使用字符串？

如果你直接用字符串形式的 ObjectId 去查询 MongoDB，可能会导致查询失败，因为 MongoDB 期望 `_id` 字段是 ObjectId 类型，而不是字符串类型。例如：

```js
// 错误的方式（直接使用字符串）
db.collection('yourCollection').findOne({ _id: '507f1f77bcf86cd799439011' }, (err, result) => {
    // 这里可能会返回 null，因为类型不匹配
});

// 正确的方式（使用 ObjectId 类型）
const ObjectId = require('mongodb').ObjectId;
const id = new ObjectId('507f1f77bcf86cd799439011');
db.collection('yourCollection').findOne({ _id: id }, (err, result) => {
    // 这里会正确返回文档
});
```


## 二.Git
### .gitignore
- 放在根目录下
- 忽略不需要上传的文件




## Nodemon(新技术以及对项目搭建的新理解)
### Nodemon
通过检测文本改动实现自动的服务器重启


### 新的理解
#### 生产和开发（dev）
发现这个东西竟然不是普通的包
依赖可以通过安装时的附加指令或者是package.json中的信息实现

开发：指项目开发时
生产：指项目投入运行时

通过安装指令npm install --save-dev nodemon实现，通常在package中添加dev的命令来启动这个功能（npm run dev）

这样做的好处是：

- 在生产环境中部署项目时，可以通过 `npm install --production` 或 `npm install`（默认行为）只安装 `dependencies` 中的依赖，而忽略 `devDependencies`，从而减少不必要的包安装，节省时间和空间。
    
- 清晰地区分开发工具和运行时依赖，便于项目管理和维护。


#### 前后端分离

#### 接口文档
使用swagger，常见的接口文档形式restful





# 临时


在前端与后端配合使用流式数据（如从 `client.chat.completions.create` 返回的流式数据）时，可以通过 WebSockets 或 Server-Sent Events (SSE) 来实现实时数据传输。以下是两种常见的实现方式：

### 1. **使用 WebSockets**

WebSockets 提供了全双工通信，允许服务器实时向客户端发送数据。以下是一个简单的实现示例：

#### **后端代码**

假设你的后端使用 Node.js 和 Express，可以使用 `ws` 库来实现 WebSocket 服务器：

JavaScript复制

```javascript
const express = require('express');
const WebSocket = require('ws');
const http = require('http');

const app = express();
const server = http.createServer(app);
const wss = new WebSocket.Server({ server });

wss.on('connection', (ws) => {
  ws.on('message', async (message) => {
    console.log('received: %s', message);

    const messages = JSON.parse(message); // 假设前端发送的消息是一个 JSON 对象
    const stream = await client.chat.completions.create({
      model: "moonshot-v1-8k",
      messages: messages,
      temperature: 0.3,
      stream: true,
    });

    for await (const chunk of stream) {
      const delta = chunk.choices[0].delta;
      if (delta.content) {
        ws.send(JSON.stringify({ content: delta.content }));
      }
    }
  });
});

server.listen(3000, () => {
  console.log('Server is running on port 3000');
});
```

#### **前端代码**

前端可以使用原生的 `WebSocket` API 来连接后端 WebSocket 服务器：

JavaScript复制

```javascript
const ws = new WebSocket('ws://localhost:3000');

ws.onopen = () => {
  console.log('Connected to WebSocket server');
  ws.send(JSON.stringify([
    { role: 'system', content: 'You are a helpful assistant.' },
    { role: 'user', content: 'Hello, how are you?' },
  ]));
};

ws.onmessage = (event) => {
  const data = JSON.parse(event.data);
  console.log('Received:', data.content);
  document.getElementById('output').innerText += data.content;
};

ws.onerror = (error) => {
  console.error('WebSocket error:', error);
};
```

### 2. **使用 Server-Sent Events (SSE)**

SSE 是一种允许服务器向客户端发送实时数据的技术，但只支持单向通信（服务器到客户端）。以下是一个实现示例：

#### **后端代码**

使用 Express 实现 SSE 服务器：

JavaScript复制

```javascript
const express = require('express');
const app = express();

app.get('/stream', async (req, res) => {
  res.setHeader('Content-Type', 'text/event-stream');
  res.setHeader('Cache-Control', 'no-cache');
  res.setHeader('Connection', 'keep-alive');

  const messages = [
    { role: 'system', content: 'You are a helpful assistant.' },
    { role: 'user', content: 'Hello, how are you?' },
  ];

  const stream = await client.chat.completions.create({
    model: "moonshot-v1-8k",
    messages: messages,
    temperature: 0.3,
    stream: true,
  });

  for await (const chunk of stream) {
    const delta = chunk.choices[0].delta;
    if (delta.content) {
      res.write(`data: ${JSON.stringify({ content: delta.content })}\n\n`);
    }
  }

  res.end();
});

app.listen(3000, () => {
  console.log('Server is running on port 3000');
});
```

#### **前端代码**

前端使用 `EventSource` API 来接收服务器发送的事件：

JavaScript复制

```javascript
const eventSource = new EventSource('http://localhost:3000/stream');

eventSource.onmessage = (event) => {
  const data = JSON.parse(event.data);
  console.log('Received:', data.content);
  document.getElementById('output').innerText += data.content;
};

eventSource.onerror = (error) => {
  console.error('EventSource error:', error);
};
```

### 3. **注意事项**

- **跨域问题**：如果前端和后端不在同一域名下，需要在后端配置 CORS（跨域资源共享）。
    
- **安全性**：确保 WebSocket 或 SSE 连接使用 HTTPS，避免数据在传输过程中被窃取。
    
- **性能优化**：对于大量数据的流式传输，可以考虑对数据进行分块处理，避免前端渲染性能问题。
    

通过以上方法，前端可以实时接收后端的流式数据，并将其展示给用户。




