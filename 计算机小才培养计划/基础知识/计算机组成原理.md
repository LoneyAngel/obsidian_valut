# 理论知识
# 第一章 总览
## 1.1冯诺依曼计算机
机器语言->汇编语言->高级语言
冯诺依曼计算机特点：
- 以运算器作为中心
- 指令和数据均以二进制的形式存储
- 指令一般是依次执行的
- 指令由操作码和地址码组成：
     - 操作码用来表示执行何种操作
     - 地址码用来表示操作数在存储器中的位置
     
## 1.2计算机系统的层次结构
![[Pasted image 20241122204843.png]]

## 1.3软件和硬件的逻辑等效性
对于一些任务既可以通过软件的方法实现也可以通过硬件的方法实现

## 1.4现代计算机的结构
![[Pasted image 20241122202905.png]]
![[Pasted image 20241122202915.png]]

## 1.5算术逻辑单元ALU
![[Pasted image 20241122210239.png]]


## 1.6机器指令的阅读
![[Pasted image 20241122211847.png]]

## 1.7计算机系统的性能指标
![[Pasted image 20241122213038.png]]


## 1.8现代计算机的改进
- 将mdr和mar集成到了cpu中
- 以存储器作为中心





# 第二章 码制

## 2.2 进位计数制，数据转换

### 十进制到二进制->十数制到任意进制
#### 整数
**方法：除以2取余法：
    - 将10进制数不断除以2，记录每次的商和余数。
    - 当商为0时停止。
    - 将所有余数逆序排列，得到的就是二进制数。
#### 小数
乘基取整

示例：将10进制数13转换为二进制数
1. 13 ÷ 2 = 6 余 1
2. 6 ÷ 2 = 3 余 0
3. 3 ÷ 2 = 1 余 1
4. 1 ÷ 2 = 0 余 1
将余数逆序排列：1101

所以，13的二进制表示为 `1101`。
### 二进制，十进制，八进制，十六进制之间的转换
二进制的3位对应八进制的1位
二进制的4位对应十六进制的1位（16进制，A表示10，依次可得）

## 2.3原反补码
### 原码
![[Pasted image 20241123133329.png]]
![[Pasted image 20241123133522.png]]


### 补码
![[Pasted image 20241123133921.png]]


### 反码
![[Pasted image 20241123134743.png]]

### 移码
![[Pasted image 20241123135329.png]]



### 特殊
![[Pasted image 20241123134915.png]]

- 移码保留原有数字的大小关系
- 不同码制的表示范围：补码：-2^n - 2^n -2^n
                    原码：
                    反码：
  
    移码的优势![[Pasted image 20241123165329.png]]
### 转换

![[Pasted image 20241123140026.png]]

## 2.4 浮点数的表示

定点数
![[Pasted image 20241123142221.png]]

- 小数点隐藏

### 浮点数的表示
二进制浮点数可采取十进制科学计数法的方法计数
如下：
![[Pasted image 20241123161238.png]]


![[Pasted image 20241123161330.png]]

#### 浮点数的表示范围
![[Pasted image 20241123162450.png]]


![[Pasted image 20241123163237.png]]
## 2.5浮点数的规格化
- 要求浮点数的位数的最高位必须是1

![[Pasted image 20241123163543.png]]



### IEEE 754标准
![[Pasted image 20241123165724.png]]

![[Pasted image 20241123170247.png]]
## 2.6   C语言中数据的转换
- 前置知识
	- 在计算机中无符号数以机器数的形式存在
	- 有符号数以补码的形式存在
**我的意思是：
比如：int a=577;
a是有符号数，那就按照有符号数来看，（好像是64位吧），直接转换成64位的机器码，，这就是对应的补码形式，最高位就是符号
### 相同字长的转换
有符号数和无符号数之间的转化


### 不同字长的相互转化

#### 小字长转换成大字长

![[Pasted image 20241123171426.png]]

#### 大字长转换成小字长

处理方法：直接截断->很可能出错



![[Pasted image 20241123171931.png]]




### 最后一类
![[Pasted image 20241130144201.png]]







# 第三章 运算

## 3.1 移位运算
### 3.1.1 逻辑移位（补0）
**对象：无符号数
逻辑左/右移：空位补0

#### 应用
 - c语言的位运算：<<   eg:1<<6     1左移6位（二进制）
              |=  按位或运算
![[Pasted image 20241124120838.png]]

### 3.1.2 算数移位（符号位不参与运算）
**对象：有符号数
- 移位规则    
![[Pasted image 20241125123429.png]]

#### 移位导致的问题
- 精度丢失                    结果出错![[Pasted image 20241125122949.png]]
### 3.1.3补码的另一种移位方法（符号位参与移位）
- 左移：高位移除，低位补0；
	注意：移动前后如果符号位发生变化，则发生溢出
- 右移：低位移除，高位填补符号   

#### 优点：
![[Pasted image 20241130151023.png]]

#### 应用：
![[Pasted image 20241125125309.png]]

### 3.1.3 循环移位
![[Pasted image 20241125130517.png]]

不带cf标志位的移动（cf作临时的存放位置，将临时的数据移动到空位）

带cf标志位的循环移动，示例如下：cf中有初始值
![[Pasted image 20241125130145.png]]


#### 应用
![[Pasted image 20241130151903.png]]


## 3.2定点运算
- 定点数在计算机中通常以补码的形式表示
### 3.2.1加减
![[Pasted image 20241130152310.png]]
#### 采取补码的好处
-  ==**补码的符号位可以和数值位一起参与运算==
- **==可以将减法运算转化为加法运算==

#### 判断溢出的方法
##### 方法1 
根据参与运算的两个数和运算结果进行判断

##### 方法2
![[Pasted image 20241219151103.png]]
##### 方法3：变形补码
![[Pasted image 20241130152905.png]]


### 3.2.2乘法
#### 3.2.1.1无符号数乘法
- 移位运算+加法运算
##### 通过计算机实现的逻辑（递归）
![[Pasted image 20241130195912.png]]

#### 3.2.1.2原码乘法
结果符号位：乘数和被乘数的符号位异或

#### 3.2.1.3补码乘法
![[Pasted image 20241219154801.png]]

####  3.2.1.4原码两位乘法

### 3.2.3 除法

#### 3.2.3.1 原码除法
![[Pasted image 20241219155103.png]]





## 3.3浮点数运算
### 3.3.1加减

### 3.3.2乘法
#### 3.3.1.1无符号数乘法


#### 3.3.1.2原码乘法


#### 3.3.1.3补码乘法


####  3.3.1.4原码两位乘法











# 第五章 指令
## 5.1 



## 5.2指令流水
## 概念
- 指令数
- 时钟周期（如果每段的时间不一样，取最大的一段作为时钟周期，至少为最大的一段）
- 流程线段数



### 性能
- 吞吐率
	- 实际吞吐率
	- 最大吞吐率
- 加速比
- 效率


# 真硬件------------------------------------------------
- 从这里开始进入硬件


## 运算器
![[Pasted image 20241130202541.png]]

# 第四章 存储器

## 4.1 前置知识

- 地址寄存器MAR，位数反映存储单元的个数(2^n)
- 数据寄存器MDR,自身的位数与存储字长相同
- 现代MAR和MDR都被集成到了cpu中
- - 每个存储单元由若干个存储元件组成
- 一个存储单元存储一个存储字，存储字长，单位位数
-  16进制的表示：0x开头或者 H结尾
- 内存单位
![[Pasted image 20241122210834.png]]

### 4.1.1分类 

![[Pasted image 20241130203854.png]]

### 4.1.2双译码结构和单译码结构

![[Pasted image 20241130205409.png]]

### 4.1.3性能指标

![[Pasted image 20241202110939.png]]



### 4.1.4主存基本结构

 - 译码器![[Pasted image 20241202111840.png]]
		- **单译码结构                                                            双译码结构
		- ![[Pasted image 20241202112839.png]]

### 4.1.5数据的存放

- 机器字长    和       存储字长
- 通常按照字节进行编址
- 比如：64位win系统     对于其而言： 半字：4字节对应一个地址
								字：
								字节地址：
- 大端和小端的方式![[Pasted image 20241202114403.png]]![[Pasted image 20241202114234.png]]


- 不同数据的存放
**C语言中不同数据类型在32位操作系统的大小：![[Pasted image 20241202114707.png]]

![[Pasted image 20241202114831.png]]
![[Pasted image 20241202122549.png]]

### 4.1.6 循环冗余效验码（CRC）
 - 两个数对2取模的加法和减法的值相等
 - 且等于二级制异或的结果


### 4.1.7 海明校验码







## 4.2RAM
### 4.2.1  SRAM 静态随机存取存储器
#### 4.2.1.1  存储元

- **存储单元**：每个RAM芯片包含大量的存储单元，每个单元通常负责存储一个字节的数据。
![[Pasted image 20241202132237.png]]


#### 4.2.1.2   存储元扩展
![[Pasted image 20241202132532.png]]

![[Pasted image 20241202132830.png]]

![[Pasted image 20241202135103.png]]

#### 4.2.1.3 应用
- 适用于cache等小容量，访问频繁的内存

### 4.2.2 动态随机存储器DRAM 

#### 4.2.2.1 存储元
![[Pasted image 20241202135423.png]]

#### 4.2.2.2  刷新
##### 概念
![[Pasted image 20241202140703.png]]

##### 方式分类
- 集中刷新     统一进行刷新                    统一刷新的时间太长，这段时间不能进行其他的操作
- 分散刷新     将刷新融入到存取周期中   会多刷新
- 异步刷新     将全部行的刷新分布到整个刷新周期中     综合以上的全部优点

###### 集中刷新
![[Pasted image 20241202141224.png]]

###### 分散刷新方式
![[Pasted image 20241202141320.png]]
###### 异步刷新方式
![[Pasted image 20241202141950.png]]
 

#### 4.2.2.3 应用场景
- 价格低
- 访问速度较慢
- 适用于运行内存等

### 4.2.3 比较
![[Pasted image 20241202140242.png]]

## 4.3 ROM
- 可以读，但是不能随意的写入的存储器

### 4.3.1 分类
![[Pasted image 20241218172356.png]]

### 4.3.2 PC中使用到的ROM
![[Pasted image 20241218173156.png]]


## 4.4 存储器的扩展
### 4.4.1 位扩展
![[Pasted image 20241218175800.png]]

### 4.4.2 字扩展
- 存储容量不能满足要求时
- 类似于片选信号的选择方法
- 地址线中的部分线路用于选择存储器（类似于片选信号）
![[Pasted image 20241218180443.png]]


### 4.4.3 同时扩展
**综上**



## 4.5 Cache
### 原理
- 一般选择SRAM作为cache
- 程序局部性：cache的使用原理
![[Pasted image 20241218185019.png]]
- cpu从缓慢的访问内存到访问cache



### 性能
![[Pasted image 20241218194247.png]]


### 4.5.1 cache的读,写操作
![[Pasted image 20241218194818.png]]

### 4.5.2 地址映射

#### 4.5.2.1 直接映射
![[Pasted image 20241218195125.png]]

- 映射的演示
![[Pasted image 20241218200520.png]]

##### 特点
- cache的利用率低
- 命中率低
- 冲突率高

综上：- 成本低，适合大容量的cache
	   - 替换的算法简单



#### 4.5.2.2 地址映射
![[Pasted image 20241218203836.png]]
##### 特点
- 命中率高
- 成本高





#### 4.5.2.3组相联映射
![[Pasted image 20241218204345.png]]




# 第五章 控制单元CU



# 第六章 总线
## 6.1 性能
- 波特率
	- 单位时间传输数据量
	- 以bps作为单位
- 比特率
	- 单位时间传输的有效数据（即数据位）量
	- 以bps作为单位


- 异步串行通信
	- 起始位是低电平
	- 终值位是高电平
	- 1高，0低
































# 习题
## 第一章
![[Pasted image 20241122203550.png]]

![[Pasted image 20241122203529.png]]
![[Pasted image 20241122203659.png]]

![[Pasted image 20241122204122.png]]

![[Pasted image 20241122204212.png]]
![[Pasted image 20241122204421.png]]
![[Pasted image 20241122205305.png]]

![[Pasted image 20241122212606.png]]
## 第二章
![[Pasted image 20241123140343.png]]![[Pasted image 20241123141400.png]]![[Pasted image 20241123141518.png]]![[Pasted image 20241123164144.png]]
![[Pasted image 20241130140651.png]]
![[Pasted image 20241123164742.png]]
![[Pasted image 20241123164823.png]]![[Pasted image 20241123171004.png]]![[Pasted image 20241130145810.png]]


## 第三章
![[Pasted image 20241124121133.png]]

![[Pasted image 20241130153201.png]]



## 第四章

![[Pasted image 20241218174002.png]]
![[Pasted image 20241202120611.png]]
![[Pasted image 20241202120848.png]]

![[Pasted image 20241202134752.png]]

![[Pasted image 20241202142316.png]]![[Pasted image 20241202143350.png]]
![[Pasted image 20241218182713.png]]
![[Pasted image 20241218183626.png]]![[Pasted image 20241218184155.png]]




