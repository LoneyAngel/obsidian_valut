- 注意：这里要求使用c++11标准
- 这里参考
[【C++】蓝桥杯必备 算法竞赛常用STL万字总结_算法竞赛允许哪些stl-CSDN博客](https://blog.csdn.net/weixin_49486457/article/details/123439229)

- 终极目标
![[Pasted image 20250118204448.png]]






# 基础
## 一.String
- 长度，s.length()
	注：std::string 的成员函数 length() 的返回值类型为 unsigned 类型，因此当 s.length() < t.length() 时，二者相减会得到一个很大的数产生运行时错误，所以相减之前需要先将二者强制类型转换为 int 类型。
- substr()
- push_back()
- insert()
- find(字串，起始位置) : 找不到返回string::npos


## 二.Vector





## 三.pair

- 初始化
	pair<int, int >={1，1}
	pair<string,int> p("hello",1);
	p = make_pair("hello",1);

- 访问
	p("hello",1);
	p.first; //第一个元素 =hello
	p.second; //第二个元素 = 1

- 排序
**当pair 结合 sort()函数使用的时候， pair 默认对first升序，当first相同时对second升序（从小到大）**

## 四.Queue和priority_queue

- 常见的操作
	q.push(); //往队尾插入一个元素 
	q.pop(); //队列：把队头弹出 ；优先队列 ：弹出堆顶元素
	
	- 区别  
		队列：
		```cpp
		q.front();// 返回队头元素
		q.back(); //返回队尾元素
		```
		
		优先队列：
		```cpp
		 q.top();// 返回堆顶元素
	```
	
	- 清空  
		注意：队列和堆没有`clear`函数  
		所以清空的方法就是重新初始化
		```cpp
		q = queue <int> ();
	```


### priority_queue
```c++
priority_queue <\int> q; //默认是大根堆
//定义小根堆 
priority_queue <类型,vecotr <类型>,greater <类型>> 变量名
```


## 五.Stack




## 六.deque【双向队列】
- 常见的操作
	dq.front(); //返回第一个元素
	dq.back(); //返回最后一个元素
	dq.push_back(); //向最后插入一个元素
	dq.pop_back(); //弹出最后一个元素
	dq.push_front(); //向队首插入一个元素
	dq.pop_front();//弹出第一个元素
	dq.begin(); //双端队列的第0个数
	dq.end(); //双端队列的最后一个的数的后面一个数

## 七.set
set不允许元素重复，如果有重复就会被忽略，但multiset允许.
- 常用函数
	size();// 返回元素个数
	empty(); //返回set是否是空的
	clear(); //清空
	begin(); //第0个数，支持++或--，返回前驱和后继
	end(); //最后一个的数的后面一个数，支持++或--，返回前驱和后继
	insert(); //插入一个数
	find(); //查找一个数
	count(); //返回某一个数的个数
	erase(x); //删除所以x  时间复杂度 O(k + logn)
    erase(s.begin(),s.end());//删除一个迭代器

- 核心函数
	lower_bound(x); //返回大于等于x的最小的数的迭代器  核心操作
	upper_bound(x); //返回大于x的最小的数的迭代器  不存在返回end()

## 八.Map







## 九.bitset 【压位】
- 二进制数据类型


## 十.unordered【哈希表】



# Algorithm(算法)
## 须知
- __gcd （）最大公约数
- max(),min()
- sort()  
```c++
int cmp(int a, int b)
{
return a > b; 
}
sort(b.begin(),b.end(),cmp); //从大到小,根据提供的函数进行大小的判断
```
- swap()
- binary_search(a, a + 5, 2); // 二分查找区间[0, 5)内是否存在元素2，若存在返回true否则返回false
- reverse()
- lower_bound()与upper_bound() [二分查找]
https://i-blog.csdnimg.cn/blog_migrate/fa52c03dc82e9d1c155cacf0610fb126.png
- 差分算法
```c++
	adjacent_difference(a, a + 5, b);  // 计算数组a区间[0, 5)内的差分并将结果保存至数组b中，b = { 1, 1, 1, 1, 1 }
	adjacent_difference(a, a + 5, b, plus<int>());  // 计算相邻两元素的和，b = { 1, 3, 5, 7, 9 }
	adjacent_difference(a, a + 5, b, multiplies<int>());  // 计算相邻两元素的乘积，b = { 1, 2, 6, 12, 20 }
```

### next_permutation()
用于生成给定序列的下一个字典序更大的排列。如果当前序列已经是字典序最大的排列，则 `std::next_permutation` 会将序列重置为字典序最小的排列，并返回 `false`，否则返回 `true`。
#### 查找步骤
1. **从后向前查找**：
    - 从序列的末尾开始向前查找，找到第一个满足 `*(i-1) < *i` 的位置 `i`。
    - 如果找不到这样的位置，说明当前序列已经是字典序最大的排列，算法将序列重置为字典序最小的排列，并返回 `false`。
        
2. **从后向前查找大于 `*(i-1)` 的元素**：
    - 从序列的末尾开始向前查找，找到第一个满足 `*j > *(i-1)` 的位置 `j`。
        
3. **交换 `*(i-1)` 和 `*j`**：
    - 交换 `*(i-1)` 和 `*j` 的值。
        
4. **反转 `i` 之后的序列**：
    - 反转 `i` 之后的序列，使其变为字典序最小的排列。

##### 作用
- 生成全排列
```c++
int main() {
    std::vector<int> vec = {1, 2, 3};

    // 生成所有排列
    do {
        for (int i : vec) {
            std::cout << i << " ";
        }
        std::cout << std::endl;
    } while (std::next_permutation(vec.begin(), vec.end()));

    return 0;
}
```
- 像sort一样，可以自定义比较函数
```cpp
while (std::next_permutation(vec.begin(), vec.end(), [](int a, int b) { return a > b; }));
```







### 迭代器
- 注意：对于容器而言的迭代器，如vector a,a.begin()指向的是第一个元素,a.end()指向的是最后一个元素后一个位置


### unique
	 用于移除序列中连续重复的元素。它属于标准模板库（STL）中的算法。`std::unique` 通常用于处理排序后的容器，因为它只能移除连续重复的元素。（实际上并没有移除，只是被放到了后面）
1. **`std::unique` 的返回值**：
    - `std::unique` 函数接受两个迭代器参数，表示要处理的范围 `[first, last)`。
    - 它返回一个迭代器，指向处理后的新末尾位置，即所有不重复元素之后的位置。
        
2. **`vec.erase(last, vec.end())` 的作用**：
    - `vec.erase(last, vec.end())` 用于删除 `[last, vec.end())` 范围内的所有元素。
    - 这样，容器 `vec` 的大小会缩小，只保留不重复的元素。

### sort
- 使用快速排序的变形，排序表现优异

# 算法概念篇

- 离散化
这道题
[【算法基础】离散化 AcWing 802. 区间和 （详细）_离散点 计算80%数据分布的区间-CSDN博客](https://blog.csdn.net/weixin_49486457/article/details/122770861?spm=1001.2014.3001.5502)

- 排序+去重
sort(v.begin(),v.end());
v.erase(unique(v.begin(),v.end()),v.end());




## 常见算法
**算法：基础扎实
		什么时候用什么
		为什么用（清楚）


### 二分查找

- 注意一下的争议皆在不是为了得到和target相等的值的位置
#### 初版

```c++
if (xin<a.back() && xin>a.front()) {
	int start = 1,mo=n;//关键点1（其实这个没有毛病）
	while (start<=mo)//关键点2
	{
		int mid = (start + mo) / 2;
		if (xin == a[mid]) cout << mid;
		else if (xin < a[mid]) mo = mid - 1;//关键点3
		else start = mid +1;//关键点4
	}
}
```

**现在就有了一个新的问题，最后的left和right以及mid分别有什么意义？


**我觉的这样好理解：
right = mid; // 答案在区间 [left, mid] 中，
left = mid + 1; // 答案在区间 [mid+1, right] 中
每次的缩小区间本质上是为了缩小查找的范围，
这样来判断right和left的更新值




- 结论：shuzu[right]<=target<=shuzu[left],
	  这个对于二分查找普遍时适用的，但是我们发现如果不是为了寻找和target相同的值，而是：shuzu[right]<target<shuzu[left]，这样的值的位置，可以进行一些改进


#### 改进版
##### 改进1版
结束条件：left == right，这个值就是我们需要的值，及左边界或是右边界
    每次更新值：left或right的值：left=mid（为了得到左边界）或right=mid（为了得到右边界）
    还是上面的那种理解方式
**我觉得这种其实较初版少了一步，得到提前得到右边界

##### 2版
结束条件：left = = right-1，及左边界和右边界
    每次更新值：left或right的值：left=mid（为了得到左边界）right=mid（为了得到右边界）
    还是上面的那种理解方式
**我觉得这种其实较初版少了两步，得到提前得到边界








- 双指针查找(这里+二分查找)
	```c++
	int low = 0, high = numbers.size() - 1;
	        while (low < =high) {//关键点2
	            int sum = numbers[low] + numbers[high];
	            if (sum == target) {
	                return {low + 1, high + 1};
	            } else if (sum < target) {
	                ++low;
	            } else {
	                --high;
	            }
	        }
	        return {-1, -1};
	```


- 快慢指针

- 实现矩阵90°旋转
	- 最快的方法：复制
	- 不使用额外空间的方法！！！：上下反转->对角线反转,




### 模拟
模拟人的思路，比如一个矩阵螺旋填值




- emplace()c++提供的一种更加高效的插入方法
- 对于一些对象在使用的时候尽量采取引用的方法，比如使用auto & a=....;,当数据量很大的时候，进行的操作应该都尽量使用已经创建的对象的引用